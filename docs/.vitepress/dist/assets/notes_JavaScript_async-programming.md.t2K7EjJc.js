import{_ as e,c as i,o as r,ae as t}from"./chunks/framework.AuAgbSZ-.js";const h=JSON.parse('{"title":"异步编程","description":"","frontmatter":{},"headers":[],"relativePath":"notes/JavaScript/async-programming.md","filePath":"notes/JavaScript/async-programming.md"}'),o={name:"notes/JavaScript/async-programming.md"};function s(n,a,l,c,p,m){return r(),i("div",null,[...a[0]||(a[0]=[t('<h1 id="异步编程" tabindex="-1">异步编程 <a class="header-anchor" href="#异步编程" aria-label="Permalink to &quot;异步编程&quot;">​</a></h1><h2 id="回调函数" tabindex="-1">回调函数 <a class="header-anchor" href="#回调函数" aria-label="Permalink to &quot;回调函数&quot;">​</a></h2><p>回调函数是异步编程的基本模式。它是一种将函数作为参数传递给另一个函数的函数。当被调用的函数执行完毕后，它将结果作为参数传递给回调函数。</p><p>回调函数的缺点是代码的可读性差，不利于维护，并且容易造成回调地狱。</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h2><p>Promise 是异步编程的一种解决方案。它是一种对象，代表一个异步操作的最终结果。Promise 提供了统一的 API，使得异步操作可以像同步操作一样方便。</p><p>Promise 有三种状态：</p><ul><li>Pending：初始状态，表示异步操作还没有完成。</li><li>Fulfilled：操作成功完成。</li><li>Rejected：操作失败。</li></ul><p>Promise 提供了 then 方法，用于指定成功和失败的回调函数。then 方法返回一个新的 Promise 对象，可以链式调用。</p><p>Promise 的优点是可以避免回调地狱，并且可以处理错误。</p><h2 id="async-await" tabindex="-1">Async/Await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;Async/Await&quot;">​</a></h2><p>Async/Await 是基于 Promise 的语法糖。它让异步操作变得更加方便，更像同步操作。</p><p>Async/Await 允许在函数中使用 await 关键字，它会暂停函数执行，等待 Promise 完成，并返回 Promise 的结果。</p><p>Async/Await 的优点是可以让代码更简洁，更易读，并且可以处理错误。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>异步编程是一种重要的编程模式，它可以让程序在等待异步操作完成时继续执行其他任务。回调函数、Promise 和 Async/Await 是异步编程的三种常用解决方案。它们各有优缺点，适用于不同的场景。在实际开发中，我们需要根据具体情况选择合适的异步编程方案。</p>',16)])])}const P=e(o,[["render",s]]);export{h as __pageData,P as default};
